"use strict";

require("core-js/modules/es.object.from-entries");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reverseTargetMappings = reverseTargetMappings;
exports.default = DetermineTargetsFromConfig;
exports.Versioning = Versioning;
exports.STANDARD_TARGET_NAME_MAPPING = void 0;

var _browserslist = _interopRequireDefault(require("browserslist"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const STANDARD_TARGET_NAME_MAPPING = {
  chrome: 'Chrome',
  firefox: 'Firefox',
  safari: 'Safari',
  ios_saf: 'iOS Safari',
  ie: 'IE',
  ie_mob: 'IE Mobile',
  edge: 'Edge',
  baidu: 'Baidu',
  electron: 'Electron',
  blackberry_browser: 'Blackberry Browser',
  edge_mobile: 'Edge Mobile',
  and_uc: 'Android UC Browser',
  and_chrome: 'Android Chrome',
  and_firefox: 'Android Firefox',
  and_webview: 'Android Webview',
  and_samsung: 'Samsung Browser',
  and_opera: 'Opera Android',
  opera: 'Opera',
  opera_mini: 'Opera Mini',
  opera_mobile: 'Opera Mobile',
  node: 'Node.js',
  kaios: 'KaiOS'
};
exports.STANDARD_TARGET_NAME_MAPPING = STANDARD_TARGET_NAME_MAPPING;

function reverseTargetMappings(targetMappings) {
  const reversedEntries = Object.entries(targetMappings).map(entry => entry.reverse());
  return Object.fromEntries(reversedEntries);
}

/**
 * Determine the targets based on the browserslist config object
 *
 * @param configPath - The file or a directory path to look for the browserslist config file
 */
function DetermineTargetsFromConfig(configPath, config) {
  const browserslistOpts = {
    path: configPath
  };

  if (Array.isArray(config) || typeof config === 'string') {
    return (0, _browserslist.default)(config, browserslistOpts);
  }

  if (config && typeof config === 'object') {
    return (0, _browserslist.default)([...(config.production || []), ...(config.development || [])], browserslistOpts);
  }

  return (0, _browserslist.default)(undefined, browserslistOpts);
}
/**
 * Take a list of targets returned from browserslist api, return the lowest version
 * version of each target
 */


function Versioning(targetslist) {
  return targetslist // Sort the targets by target name and then version number in ascending order
  .map(e => {
    const [target, version] = e.split(' ');
    return {
      target,
      version,
      parsedVersion: version === 'all' ? 0 : version.includes('-') ? parseFloat(version.split('-')[0]) : parseFloat(version)
    };
  }) // Sort the targets by target name and then version number in descending order
  // ex. [a@3, b@3, a@1] => [a@3, a@1, b@3]
  .sort((a, b) => {
    if (b.target === a.target) {
      // If any version === 'all', return 0. The only version of op_mini is 'all'
      // Otherwise, compare the versions
      return typeof b.parsedVersion === 'string' || typeof a.parsedVersion === 'string' ? 0 : b.parsedVersion - a.parsedVersion;
    }

    return b.target > a.target ? 1 : -1;
  }) // First last target always has the latest version
  .filter((e, i, items) => // Check if the current target is the last of its kind. If it is, then it
  // is most recent version
  i + 1 === items.length || e.target !== items[i + 1].target);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9WZXJzaW9uaW5nLmpzIl0sIm5hbWVzIjpbIlNUQU5EQVJEX1RBUkdFVF9OQU1FX01BUFBJTkciLCJjaHJvbWUiLCJmaXJlZm94Iiwic2FmYXJpIiwiaW9zX3NhZiIsImllIiwiaWVfbW9iIiwiZWRnZSIsImJhaWR1IiwiZWxlY3Ryb24iLCJibGFja2JlcnJ5X2Jyb3dzZXIiLCJlZGdlX21vYmlsZSIsImFuZF91YyIsImFuZF9jaHJvbWUiLCJhbmRfZmlyZWZveCIsImFuZF93ZWJ2aWV3IiwiYW5kX3NhbXN1bmciLCJhbmRfb3BlcmEiLCJvcGVyYSIsIm9wZXJhX21pbmkiLCJvcGVyYV9tb2JpbGUiLCJub2RlIiwia2Fpb3MiLCJyZXZlcnNlVGFyZ2V0TWFwcGluZ3MiLCJ0YXJnZXRNYXBwaW5ncyIsInJldmVyc2VkRW50cmllcyIsIk9iamVjdCIsImVudHJpZXMiLCJtYXAiLCJlbnRyeSIsInJldmVyc2UiLCJmcm9tRW50cmllcyIsIkRldGVybWluZVRhcmdldHNGcm9tQ29uZmlnIiwiY29uZmlnUGF0aCIsImNvbmZpZyIsImJyb3dzZXJzbGlzdE9wdHMiLCJwYXRoIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvZHVjdGlvbiIsImRldmVsb3BtZW50IiwidW5kZWZpbmVkIiwiVmVyc2lvbmluZyIsInRhcmdldHNsaXN0IiwiZSIsInRhcmdldCIsInZlcnNpb24iLCJzcGxpdCIsInBhcnNlZFZlcnNpb24iLCJpbmNsdWRlcyIsInBhcnNlRmxvYXQiLCJzb3J0IiwiYSIsImIiLCJmaWx0ZXIiLCJpIiwiaXRlbXMiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUNBOzs7O0FBR08sTUFBTUEsNEJBQTRCLEdBQUc7QUFDMUNDLEVBQUFBLE1BQU0sRUFBRSxRQURrQztBQUUxQ0MsRUFBQUEsT0FBTyxFQUFFLFNBRmlDO0FBRzFDQyxFQUFBQSxNQUFNLEVBQUUsUUFIa0M7QUFJMUNDLEVBQUFBLE9BQU8sRUFBRSxZQUppQztBQUsxQ0Ms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Q0FBQyxDQUFDSixhQUFULEtBQTJCLFFBRHRCLEdBRUgsQ0FGRyxHQUdISyxDQUFDLENBQUNMLGFBQUYsR0FBa0JJLENBQUMsQ0FBQ0osYUFIeEI7QUFJRDs7QUFDRCxXQUFPSyxDQUFDLENBQUNSLE1BQUYsR0FBV08sQ0FBQyxDQUFDUCxNQUFiLEdBQXNCLENBQXRCLEdBQTBCLENBQUMsQ0FBbEM7QUFDRCxHQTNCSCxFQTRCRTtBQTVCRixHQTZCR1MsTUE3QkgsQ0E4QkksQ0FBQ1YsQ0FBRCxFQUFvQlcsQ0FBcEIsRUFBK0JDLEtBQS9CLEtBQ0U7QUFDQTtBQUNBRCxFQUFBQSxDQUFDLEdBQUcsQ0FBSixLQUFVQyxLQUFLLENBQUNDLE1BQWhCLElBQTBCYixDQUFDLENBQUNDLE1BQUYsS0FBYVcsS0FBSyxDQUFDRCxDQUFDLEdBQUcsQ0FBTCxDQUFMLENBQWFWLE1BakMxRCxDQURGO0FBcUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCBicm93c2Vyc2xpc3QgZnJvbSAnYnJvd3NlcnNsaXN0JztcbmltcG9ydCB0eXBlIHsgQnJvd3Nlckxpc3RDb25maWcgfSBmcm9tICcuL0xpbnRUeXBlcyc7XG5cbmV4cG9ydCBjb25zdCBTVEFOREFSRF9UQVJHRVRfTkFNRV9NQVBQSU5HID0ge1xuICBjaHJvbWU6ICdDaHJvbWUnLFxuICBmaXJlZm94OiAnRmlyZWZveCcsXG4gIHNhZmFyaTogJ1NhZmFyaScsXG4gIGlvc19zYWY6ICdpT1MgU2FmYXJpJyxcbiAgaWU6ICdJRScsXG4gIGllX21vYjogJ0lFIE1vYmlsZScsXG4gIGVkZ2U6ICdFZGdlJyxcbiAgYmFpZHU6ICdCYWlkdScsXG4gIGVsZWN0cm9uOiAnRWxlY3Ryb24nLFxuICBibGFja2JlcnJ5X2Jyb3dzZXI6ICdCbGFja2JlcnJ5IEJyb3dzZXInLFxuICBlZGdlX21vYmlsZTogJ0VkZ2UgTW9iaWxlJyxcbiAgYW5kX3VjOiAnQW5kcm9pZCBVQyBCcm93c2VyJyxcbiAgYW5kX2Nocm9tZTogJ0FuZHJvaWQgQ2hyb21lJyxcbiAgYW5kX2ZpcmVmb3g6ICdBbmRyb2lkIEZpcmVmb3gnLFxuICBhbmRfd2VidmlldzogJ0FuZHJvaWQgV2VidmlldycsXG4gIGFuZF9zYW1zdW5nOiAnU2Ftc3VuZyBCcm93c2VyJyxcbiAgYW5kX29wZXJhOiAnT3BlcmEgQW5kcm9pZCcsXG4gIG9wZXJhOiAnT3BlcmEnLFxuICBvcGVyYV9taW5pOiAnT3BlcmEgTWluaScsXG4gIG9wZXJhX21vYmlsZTogJ09wZXJhIE1vYmlsZScsXG4gIG5vZGU6ICdOb2RlLmpzJyxcbiAga2Fpb3M6ICdLYWlPUydcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlVGFyZ2V0TWFwcGluZ3ModGFyZ2V0TWFwcGluZ3MpIHtcbiAgY29uc3QgcmV2ZXJzZWRFbnRyaWVzID0gT2JqZWN0LmVudHJpZXModGFyZ2V0TWFwcGluZ3MpLm1hcChlbnRyeSA9PlxuICAgIGVudHJ5LnJldmVyc2UoKVxuICApO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHJldmVyc2VkRW50cmllcyk7XG59XG5cbnR5cGUgVGFyZ2V0TGlzdEl0ZW0gPSB7XG4gIHRhcmdldDogc3RyaW5nLFxuICBwYXJzZWRWZXJzaW9uOiBudW1iZXIsXG4gIHZlcnNpb246IHN0cmluZyB8ICdhbGwnXG59O1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgdGFyZ2V0cyBiYXNlZCBvbiB0aGUgYnJvd3NlcnNsaXN0IGNvbmZpZyBvYmplY3RcbiAqXG4gKiBAcGFyYW0gY29uZmlnUGF0aCAtIFRoZSBmaWxlIG9yIGEgZGlyZWN0b3J5IHBhdGggdG8gbG9vayBmb3IgdGhlIGJyb3dzZXJzbGlzdCBjb25maWcgZmlsZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZXRlcm1pbmVUYXJnZXRzRnJvbUNvbmZpZyhcbiAgY29uZmlnUGF0aDogc3RyaW5nLFxuICBjb25maWc/OiBCcm93c2VyTGlzdENvbmZpZ1xuKTogQXJyYXk8c3RyaW5nPiB7XG4gIGNvbnN0IGJyb3dzZXJzbGlzdE9wdHMgPSB7IHBhdGg6IGNvbmZpZ1BhdGggfTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpIHx8IHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGJyb3dzZXJzbGlzdChjb25maWcsIGJyb3dzZXJzbGlzdE9wdHMpO1xuICB9XG5cbiAgaWYgKGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBicm93c2Vyc2xpc3QoXG4gICAgICBbLi4uKGNvbmZpZy5wcm9kdWN0aW9uIHx8IFtdKSwgLi4uKGNvbmZpZy5kZXZlbG9wbWVudCB8fCBbXSldLFxuICAgICAgYnJvd3NlcnNsaXN0T3B0c1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gYnJvd3NlcnNsaXN0KHVuZGVmaW5lZCwgYnJvd3NlcnNsaXN0T3B0cyk7XG59XG5cbi8qKlxuICogVGFrZSBhIGxpc3Qgb2YgdGFyZ2V0cyByZXR1cm5lZCBmcm9tIGJyb3dzZXJzbGlzdCBhcGksIHJldHVybiB0aGUgbG93ZXN0IHZlcnNpb25cbiAqIHZlcnNpb24gb2YgZWFjaCB0YXJnZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFZlcnNpb25pbmcodGFyZ2V0c2xpc3Q6IEFycmF5PHN0cmluZz4pOiBBcnJheTxUYXJnZXRMaXN0SXRlbT4ge1xuICByZXR1cm4gKFxuICAgIHRhcmdldHNsaXN0XG4gICAgICAvLyBTb3J0IHRoZSB0YXJnZXRzIGJ5IHRhcmdldCBuYW1lIGFuZCB0aGVuIHZlcnNpb24gbnVtYmVyIGluIGFzY2VuZGluZyBvcmRlclxuICAgICAgLm1hcCgoZTogc3RyaW5nKTogVGFyZ2V0TGlzdEl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBbdGFyZ2V0LCB2ZXJzaW9uXSA9IGUuc3BsaXQoJyAnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICBwYXJzZWRWZXJzaW9uOlxuICAgICAgICAgICAgdmVyc2lvbiA9PT0gJ2FsbCdcbiAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgIDogdmVyc2lvbi5pbmNsdWRlcygnLScpXG4gICAgICAgICAgICAgID8gcGFyc2VGbG9hdCh2ZXJzaW9uLnNwbGl0KCctJylbMF0pXG4gICAgICAgICAgICAgIDogcGFyc2VGbG9hdCh2ZXJzaW9uKVxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICAgIC8vIFNvcnQgdGhlIHRhcmdldHMgYnkgdGFyZ2V0IG5hbWUgYW5kIHRoZW4gdmVyc2lvbiBudW1iZXIgaW4gZGVzY2VuZGluZyBvcmRlclxuICAgICAgLy8gZXguIFthQDMsIGJAMywgYUAxXSA9PiBbYUAzLCBhQDEsIGJAM11cbiAgICAgIC5zb3J0KChhOiBUYXJnZXRMaXN0SXRlbSwgYjogVGFyZ2V0TGlzdEl0ZW0pOiBudW1iZXIgPT4ge1xuICAgICAgICBpZiAoYi50YXJnZXQgPT09IGEudGFyZ2V0KSB7XG4gICAgICAgICAgLy8gSWYgYW55IHZlcnNpb24gPT09ICdhbGwnLCByZXR1cm4gMC4gVGhlIG9ubHkgdmVyc2lvbiBvZiBvcF9taW5pIGlzICdhbGwnXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjb21wYXJlIHRoZSB2ZXJzaW9uc1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgYi5wYXJzZWRWZXJzaW9uID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGEucGFyc2VkVmVyc2lvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgOiBiLnBhcnNlZFZlcnNpb24gLSBhLnBhcnNlZFZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGIudGFyZ2V0ID4gYS50YXJnZXQgPyAxIDogLTE7XG4gICAgICB9KVxuICAgICAgLy8gRmlyc3QgbGFzdCB0YXJnZXQgYWx3YXlzIGhhcyB0aGUgbGF0ZXN0IHZlcnNpb25cbiAgICAgIC5maWx0ZXIoXG4gICAgICAgIChlOiBUYXJnZXRMaXN0SXRlbSwgaTogbnVtYmVyLCBpdGVtczogQXJyYXk8VGFyZ2V0TGlzdEl0ZW0+KTogYm9vbGVhbiA9PlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHRhcmdldCBpcyB0aGUgbGFzdCBvZiBpdHMga2luZC4gSWYgaXQgaXMsIHRoZW4gaXRcbiAgICAgICAgICAvLyBpcyBtb3N0IHJlY2VudCB2ZXJzaW9uXG4gICAgICAgICAgaSArIDEgPT09IGl0ZW1zLmxlbmd0aCB8fCBlLnRhcmdldCAhPT0gaXRlbXNbaSArIDFdLnRhcmdldFxuICAgICAgKVxuICApO1xufVxuIl19